# 前言
其他博客主要介绍链接的理论，这篇博客主要介绍链接脚本。同时，这篇博客也是为了 `xv6-arm` 做铺垫的。

> 主要参考[Scripts (LD) (sourceware.org)](https://sourceware.org/binutils/docs/ld/Scripts.html#Scripts)

#  目录
- [[#1 链接脚本]]
- [[#2 隐式链接脚本]]

# 1. 链接脚本
<mark style="background: #FFB8EBA6;">链接脚本</mark>控制着每次链接过程。链接脚本是由链接命令语言组成的。

链接脚本的主要目的是描述： <mark style="background: #BBFABBA6;">输入文件的sections 应该如何映射到 输出文件中、控制输出文件的内存布局</mark>。大多数的链接脚本都只是做这两件事情而已。但只要有需要，链接脚本还可以让链接器做其他的事情，使用后面介绍的命令就行。

链接器一直使用链接脚本进行工作。如果没有给链接器提供一个链接脚本，链接器将会使用一个默认的在编译链接器时内置的脚本。你可以使用 `--verbose` 命令选项去查看默认的链接脚本。

```shell
❯ aarch64-linux-gnu-ld --verbose
GNU ld (GNU Binutils for Ubuntu) 2.34
  Supported emulations:
   aarch64linux
   aarch64elf
   aarch64elf32
   aarch64elf32b
   aarch64elfb
   armelf
   armelfb
   aarch64linuxb
   aarch64linux32
   aarch64linux32b
   armelfb_linux_eabi
   armelf_linux_eabi
using internal linker script:
==================================================
/* Script for -z combreloc */
/* Copyright (C) 2014-2020 Free Software Foundation, Inc.
   Copying and distribution of this script, with or without modification,
   are permitted in any medium without royalty provided the copyright
   notice and this notice are preserved.  */
OUTPUT_FORMAT("elf64-littleaarch64", "elf64-bigaarch64",
              "elf64-littleaarch64")
OUTPUT_ARCH(aarch64)
ENTRY(_start)
SEARCH_DIR("=/usr/local/lib/aarch64-linux-gnu"); SEARCH_DIR("=/lib/aarch64-linux-gnu"); SEARCH_DIR("=/usr/lib/aarch64-linux-gnu"); SEARCH_DIR("=/usr/local/lib"); SEARCH_DIR("=/lib"); SEARCH_DIR("=/usr/lib"); SEARCH_DIR("=/usr/aarch64-linux-gnu/lib");
SECTIONS
{
  /* Read-only sections, merged into text segment: */
  PROVIDE (__executable_start = SEGMENT_START("text-segment", 0x400000)); . = SEGMENT_START("text-segment", 0x400000) + SIZEOF_HEADERS;
  .interp         : { *(.interp) }
  .note.gnu.build-id  : { *(.note.gnu.build-id) }
  .hash           : { *(.hash) }
......
```

某些命令行选项，如“-r”或“-N”，将影响默认的链接器脚本。

你可以通过 `-T` 选项来使用你自己的链接脚本，一旦加上这个选项，指定好脚本，就会替换默认的链接器脚本。

你也可以将间接脚本当做输入文件给到链接器，这样会<mark style="background: #FFB8EBA6;">隐式的</mark>使用链接脚本完成链接，具体见下面：

# 2. 隐式链接脚本
如果你传入的链接脚本，链接器并不能识别为 object file 或者 归档文件， 链接器就会尝试将文件当做链接脚本。如果这个文件也不能被解析为链接脚本，那链接器会报错。

隐式链接脚本将不会替换默认的链接脚本。

通常，隐式链接器脚本将只包含符号分配或 INPUT、 GROUP 或 VERION 命令。

由于隐式链接器脚本和任何输入文件都将在命令行中读取。这会影响归档文件搜寻。

# 3. 链接脚本基本概念
为了描述链接脚本语言，我们需要定义一些基本的概念和词汇。

链接器将输入文件合并为一个输出文件。输出文件和每个输入文件都是有特殊的数据格式，称为 `object file format`，(我想就是elf格式吧)。每个文件都被称为 `目标文件 (object file)`。输出文件也通常被称为可执行的，但我们这里还是将其称为目标文件。除此之外，每个对象文件都有一些节。我们有时候将输入文件的节(section)称为输入节，同样的，输出文件中的节称为输出节。





