
# 1.5.3 内置芯片
当我们讨论行为模拟的时候，我们指出我们的硬件模拟提供了基于软件的、内置实现了大多数本书描述的芯片。在nand到俄罗斯方块中，课程中最出名的内置芯片是nand：无论什么时候你在HDL程序里使用一个nand chip-part，硬件模拟器都使用内置的 tools/builtIn/Nand.hdl 实现。这种约定是更通用的芯片调用策略的一种特殊情况：每当硬件模拟器遇到一个芯片部件，比如，在HDL程序中，它查找文件Xxx。当前文件夹中的HDL;如果找到该文件，则模拟器计算其底层HDL代码。  如果没有找到该文件，模拟器将在tools/builtIn文件夹中查找它。如果在那里找到该文件，则模拟器执行芯片的内置实现;否则，模拟器将发出错误消息并终止模拟。

这个惯例会派上用场。比如说，假设你开始实现一个mux.hdl 程序，但是，由于一些原因，你没有完成它。这可能是一个恼人的挫折，因为从理论上讲，您不能继续构建使用Mux作为芯片部件的芯片。幸运的是，实际上是通过设计，这就是内置芯片来拯救的地方。您需要做的就是将部分实现重命名为Mux1。比如Hdl。每次调用硬件模拟器来模拟Mux芯片部件的功能时，它将无法找到Mux。当前文件夹中的HDL文件。这将导致行为模拟启动，迫使模拟器使用内置的Mux版本。正是我们想要的!在稍后的阶段，您可能想要回到Mux1。HDL并继续其实现工作。此时，您可以恢复其原始文件名Mux.Hdl，然后从你停下来的地方继续。

